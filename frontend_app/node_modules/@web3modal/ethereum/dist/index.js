import{disconnect as l,getAccount as h,watchAccount as d,fetchBalance as w,getNetwork as C,watchNetwork as u,switchNetwork as p,fetchEnsName as f,fetchEnsAvatar as m,connect as s,InjectedConnector as g}from"@wagmi/core";import{CoinbaseWalletConnector as I}from"@wagmi/core/connectors/coinbaseWallet";import{WalletConnectConnector as v}from"@wagmi/core/connectors/walletConnect";import{jsonRpcProvider as N}from"@wagmi/core/providers/jsonRpc";class P{constructor(n,t){this.wagmi={},this.walletConnectUri="",this.walletConnectVersion=1,this.chains=[],this.namespace="eip155",this.disconnect=l,this.getAccount=h,this.watchAccount=d,this.fetchBalance=w,this.getNetwork=C,this.watchNetwork=u,this.switchNetwork=p,this.fetchEnsName=f,this.fetchEnsAvatar=m;var e;const o=n.connectors.find(i=>i.id==="walletConnect");if(!o)throw new Error("WalletConnectConnector is required");this.wagmi=n,this.chains=t,this.walletConnectVersion=Number((e=o.options.version)!=null?e:"1")}getDefaultConnectorChainId(n){return n.chains[0].id}async connectWalletConnectV1(n,t){return new Promise((e,o)=>{n.once("message",async({type:i})=>{if(i==="connecting"){const c=(await n.getProvider()).connector;this.walletConnectUri=c.uri,t(c.uri),c.on("disconnect",()=>{o(Error())}),c.on("connect",()=>{e()})}})})}async connectWalletConnectV2(n,t){const e=await n.getProvider();let o="";return new Promise(i=>{e.once("display_uri",c=>{this.walletConnectUri=c,o=c,t(c)}),e.once("connect",()=>{o===this.walletConnectUri&&i()})})}getDefaultChain(){const n=this.chains.find(t=>t.id===1);return n??this.chains[0]}getConnectorById(n){const t=this.wagmi.connectors.find(e=>e.id===n);if(!t)throw new Error(`Connector for id ${n} was not found`);return t}getConnectors(){return this.wagmi.connectors.filter(n=>n.id!=="walletConnect")}async connectWalletConnect(n,t){const e=this.getConnectorById("walletConnect"),o=this.walletConnectVersion===1,i=t??this.getDefaultConnectorChainId(e),c=o?this.connectWalletConnectV1.bind(this):this.connectWalletConnectV2.bind(this),[a]=await Promise.all([s({connector:e,chainId:i}),c(e,n)]);return a}async connectConnector(n,t){const e=this.getConnectorById(n),o=t??this.getDefaultConnectorChainId(e);return await s({connector:e,chainId:o})}}const E="eip155";function j({projectId:r}){return N({rpc:n=>{var t;return[1,3,4,5,10,42,56,69,97,100,137,420,42161,42220,43114,80001,421611,421613,1313161554,11297108109].includes(n.id)?{http:`https://rpc.walletconnect.com/v1/?chainId=${E}:${n.id}&projectId=${r}`}:{http:n.rpcUrls.default.http[0],webSocket:(t=n.rpcUrls.default.webSocket)==null?void 0:t[0]}}})}function V({appName:r,chains:n,version:t,projectId:e}){const o=t??"1";if(o==="2"&&!e)throw new Error("modalConnectors() requires projectId for WalletConnect version 2");return[new v({chains:n,options:{qrcode:!1,version:o,projectId:e}}),new g({chains:n,options:{shimDisconnect:!0,shimChainChangedDisconnect:!0}}),new I({chains:n,options:{appName:r}})]}export{P as EthereumClient,V as modalConnectors,j as walletConnectProvider};
//# sourceMappingURL=index.js.map
