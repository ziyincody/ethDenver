System.register(["proxy-compare"],function(D){"use strict";var W,K;return{setters:[function(j){W=j.markToTrack,K=j.getUntracked}],execute:function(){D({getVersion:_,proxy:U,ref:L,snapshot:B,subscribe:q});const j=c=>typeof c=="object"&&c!==null,l=new WeakMap,m=new WeakSet,T=(c=Object.is,f=(t,v)=>new Proxy(t,v),P=t=>j(t)&&!m.has(t)&&(Array.isArray(t)||!(Symbol.iterator in t))&&!(t instanceof WeakMap)&&!(t instanceof WeakSet)&&!(t instanceof Error)&&!(t instanceof Number)&&!(t instanceof Date)&&!(t instanceof String)&&!(t instanceof RegExp)&&!(t instanceof ArrayBuffer),k=t=>{switch(t.status){case"fulfilled":return t.value;case"rejected":throw t.reason;default:throw t}},u=new WeakMap,g=(t,v,b=k)=>{const s=u.get(t);if((s==null?void 0:s[0])===v)return s[1];const a=Array.isArray(t)?[]:Object.create(Object.getPrototypeOf(t));return W(a,!0),u.set(t,[v,a]),Reflect.ownKeys(t).forEach(O=>{if(Object.getOwnPropertyDescriptor(a,O))return;const d=Reflect.get(t,O),w={value:d,enumerable:!0,configurable:!0};if(m.has(d))W(d,!1);else if(d instanceof Promise)delete w.value,w.get=()=>b(d);else if(l.has(d)){const[i,x]=l.get(d);w.value=g(i,x(),b)}Object.defineProperty(a,O,w)}),a},h=new WeakMap,y=[1,1],E=t=>{if(!j(t))throw new Error("object required");const v=h.get(t);if(v)return v;let b=y[0];const s=new Set,a=(n,r=++y[0])=>{b!==r&&(b=r,s.forEach(e=>e(n,r)))};let O=y[1];const d=(n=++y[1])=>(O!==n&&!s.size&&(O=n,i.forEach(([r])=>{const e=r[1](n);e>b&&(b=e)})),b),w=n=>(r,e)=>{const o=[...r];o[1]=[n,...o[1]],a(o,e)},i=new Map,x=(n,r)=>{if(s.size){const e=r[3](w(n));i.set(n,[r,e])}else i.set(n,[r])},V=n=>{var r;const e=i.get(n);e&&(i.delete(n),(r=e[1])==null||r.call(e))},N=n=>(s.add(n),s.size===1&&i.forEach(([r,e],o)=>{const z=r[3](w(o));i.set(o,[r,z])}),()=>{s.delete(n),s.size===0&&i.forEach(([r,e],o)=>{e&&(e(),i.set(o,[r]))})}),S=Array.isArray(t)?[]:Object.create(Object.getPrototypeOf(t)),R=f(S,{deleteProperty(n,r){const e=Reflect.get(n,r);V(r);const o=Reflect.deleteProperty(n,r);return o&&a(["delete",[r],e]),o},set(n,r,e,o){const z=Reflect.has(n,r),M=Reflect.get(n,r,o);if(z&&(c(M,e)||h.has(e)&&c(M,h.get(e))))return!0;V(r),j(e)&&(e=K(e)||e);let A=e;if(e instanceof Promise)e.then(p=>{e.status="fulfilled",e.value=p,a(["resolve",[r],p])}).catch(p=>{e.status="rejected",e.reason=p,a(["reject",[r],p])});else{!l.has(e)&&P(e)&&(A=E(e));const p=!m.has(A)&&l.get(A);p&&x(r,p)}return Reflect.set(n,r,A,o),a(["set",[r],e,M]),!0}});h.set(t,R);const C=[S,d,g,N];return l.set(R,C),Reflect.ownKeys(t).forEach(n=>{const r=Object.getOwnPropertyDescriptor(t,n),e="value"in r;delete r.value,Object.defineProperty(S,n,r),e&&(R[n]=t[n])}),R})=>[E,l,m,c,f,P,k,u,g,h,y],[F]=T();function U(c={}){return F(c)}function _(c){const f=l.get(c);return f==null?void 0:f[1]()}function q(c,f,P){const k=l.get(c);let u;const g=[],h=k[3];let y=!1;const E=h(t=>{if(g.push(t),P){f(g.splice(0));return}u||(u=Promise.resolve().then(()=>{u=void 0,y&&f(g.splice(0))}))});return y=!0,()=>{y=!1,E()}}function B(c,f){const P=l.get(c),[k,u,g]=P;return g(k,u(),f)}function L(c){return m.add(c),c}const G=D("unstable_buildProxyFunction",T)}}});
